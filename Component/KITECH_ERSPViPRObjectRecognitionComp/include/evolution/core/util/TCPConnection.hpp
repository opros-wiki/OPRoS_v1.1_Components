//  Copyright (C) 2001-2007, Evolution Robotics, Inc.
//  Any reproduction is strictly prohibited without the explicit
//  written permission of Evolution Robotics, Inc.  All rights reserved.


/**
 * @file    evolution/core/util/TCPConnection.hpp
 * @brief   Implements a TCP client connection to TCPConnectionServer.
 * @author  Copyright (C) 2001-2007, Evolution Robotics, Inc.
 * @see Evolution::TCPConnectionServer
 * @see Evolution::TCPConnection
 * @see Evolution::InputThread
 * @see Evolution::OutputThread
 */

#ifndef EVOLUTION_LIBRARIES_BASE_TCP_CONNECTION_HPP
#define EVOLUTION_LIBRARIES_BASE_TCP_CONNECTION_HPP

#include <string>
#include <list>
#include <memory>
#include <evolution/core/util/ISocketProtocol.hpp>
#include <evolution/core/util/SignalThread.hpp>
#include <evolution/core/util/TCPClient.hpp>
#include <evolution/core/util/ThreadPool.hpp>
#include <evolution/core/base/ObjectImpl.hpp>
#include <evolution/core/base/RefPtr.hpp>

namespace Evolution {

    // Forward declaration.
    class EVOLUTION_EXPORT_UTIL TCPConnectionServer;

    /**
     * @class TCPConnection
     * 
     * @brief
     * A class implementing a socket-based client to TCPConnectionServer.
     *
     * So what is the difference between a TCPConnection and a TCPClient?
     *
     * First of all, a TCPClient is standalone - you can use it by itself
     * to connect to a TCP server and send/receive data.  A TCPConnection
     * runs its own send and receive threads.
     *
     * Second of all, a TCPConnection is associated with a TCPConnectionServer,
     * whereas a TCPClient is associated with a TCPServer.
     *
     * Third of all, a TCPConnection does its own buffering - it buffers
     * packets if the connection is backed up.
     * 
     * @ingroup core_util
     */
    class EVOLUTION_EXPORT_UTIL TCPConnection : public ObjectImpl 
    {
    protected:
        // Forward declaration.
        class EVOLUTION_EXPORT_UTIL InputThread;
        class EVOLUTION_EXPORT_UTIL OutputThread;
        
    public: // Structors.
        /**
         * @brief
         * Constructor for a connection spawned by accept() on a server.
         *
         * @param server [in]; pointer to server that accepted the
         *          connection.
         * @param s    [in]; The socket generated by accept().
         * @param addr [in]; The client address generated by accept().
         */
        TCPConnection(TCPConnectionServer* server, SOCKET s, sockaddr* addr);
        
        /**
         * @brief
         * Constructor for a connection created by a client, used to connect to
         * a server.
         *
         * @param   host    [in]; The IP address or host name to which the
         *                       client should connect.  
         * @param   port    [in]; The port to which the client should connect.
         */
        TCPConnection(const char* host, unsigned short port);


        /**
         * Destructor.
         */
        virtual ~TCPConnection();

        /**
         * @brief
         * Init function which handles starting the thread
         * and making the connection to the server.
         * This is done outside the constructor because it
         * involves virtual function calls.
         *
         * @param   timeout_seconds    [in]; How long to wait for connection to
         * be made before timing out.  If timeout_seconds is >= 0, we put the
         * socket into non-blocking mode and wait up to timeout_seconds seconds
         * for a connection to be made.  If timeout_seconds is < 0, we perform
         * a blocking connect and rely on the Operating Sytem's internal
         * timeout for failed connections.
         *
         */
        virtual void init( int timeout_seconds = -1 );
    
        // Overridable Interface.

    public: // Setters.

        /**
         * @brief Set the host (either IP or hostname) to connect to.
         * Call this to set the host before calling the init() function.
         * This calls invalidate_socket().
         *
         * @param host [in]; The host name to connect to.
         */
        virtual void set_connection_host(const char* host);

        /**
         * @brief Set the port to connect to..
         * Call this to set the port before calling the init() function.
         * This calls invalidate_socket().
         *
         * @param port [in]; The port number to connect to.
         */
        virtual void set_connection_port(unsigned short port);

    public: // Event_handling.
        /**
         * @brief
         * Reimplement for special handling of socket errors.
         * Note that this is likely to be called in another thread,
         * so guard your data appropriately.
         *
         * @param code [in]; The error code.
         * @param msg  [in]; The error message.
         */
        virtual void on_error(int code, const char* msg) {}

        /**
         * @brief
         * Reimplement for special handling on disconnection.
         * Note that this is likely to be called in another thread, so
         * guard your data appropriately.  Also, note that when a
         * socket is disconnected because of an error, only on_error
         * is called.
         */
        virtual void on_disconnect() {}
            
        /**
         * @brief
         * Must reimplement to handle processing of incoming data.
         * Note that this is likely to be called in another thread,
         * so guard your data appropriately.
         *
         * @param   buffer  [in]; The pointer to buffer containing message.
         * @param   buffer_size [in]; The size of message buffer.
         */
        virtual void on_read(const char* buffer, int buffer_size) {}
            
        /**
         * @brief
         * Should reimplement to create the protocol used by this client.
         *
         * Each TCPConnection-derived class must reimplement this method
         * to return a protocol object for use by the class.  This protocol
         * object must implement theISocketProtocol interface and also
         * be allocated on the heap.  Whenever a new client connection is
         * made, this method is called to create a new protocol object for
         * the client connection to encode and decode all communications to
         * and from the client.  If no encoding or decoding is necessary,
         * return a pointer to the NullProtocol object.
         *
         * @return  Pointer to a heap-allocated protocol object.
         */
        virtual ISocketProtocol* create_protocol();
            
    public: // Message handling
        /**
         * @brief
         * Send a message to a specified client using a separate thread.
         *
         * @param msg       [in]; The pointer to the message to send.
         * @param len       [in]; The length of message to send.
         */
        virtual void send_message(const char* msg, int len);
            
        /**
         * @brief
         * Send a message to a specified client using a separate thread.
         * Drop the message is the message queue is greater than 
         * (queue_length).
         *
         * @param msg       [in]; The pointer to the message to send.
         * @param len       [in]; The length of message to send.
         * @param queue_length [in]; the max length of queue before 
         *      dropping message.
         */
        virtual void send_message_check_queue_length(const char* msg, int len, size_t queue_length);
            
        /**
         * @brief
         * Used internally, don't call this.
         * @param msg       [in]; Points to message to send.
         * @param len       [in]; The length of message to send.
         */
        virtual void send_to_server(const char* msg, int len);

        /**
         * @brief
         * Sets the disconnected flag.
         */
        virtual void set_disconnected() { _disconnected = true; }

        /**
         * @brief
         * Check if a connection is disconnected.
         *
         * @return True if successful.
         */
        virtual bool is_disconnected() { return _disconnected; }

    protected: // Helpers
        /**
         * @brief  
         * Resets _socket and _disconnected, and closes _socket if needed.
         */
        void invalidate_socket();

    protected: // Attributes.
        /// The client connection's listen thread.
        std::auto_ptr<InputThread> _listen_thread;
        
        /// The client connection's send thread.
        std::auto_ptr<OutputThread> _send_thread;

        
        /// IMutex for synching server operations.       
        std::auto_ptr<IMutex> _mutex;

        String             _host;  ///< The host name of the connection.
        unsigned short     _port;  ///< The port number of the connection.
        SOCKET             _socket;  ///< The socket handle of the connection.
        TCPConnectionServer* _server;  ///< Corresponding server for spawned connections - I do not own this pointer.
        bool               _disconnected; ///< True if the connection is disconnected.

        // Nested helper classes.
        
        /**
         * @class InputThread
         * @ingroup core_util
         * @brief
         * Thread that handles the socket input. 
         */
        class EVOLUTION_EXPORT_UTIL InputThread : public SignalThread  
        {
        public:
            /**
             * @brief
             * Constructor.
             *
             * @param   conn     [in]; The reference to the connection serviced
             *      by this thread.  
             * @param   protocol [in]; Which protocol to use on the socket.
             * @param   socket   [in]; The socket on which this thread will 
             *      operate.
             */
            InputThread(TCPConnection& conn, ISocketProtocol* protocol, SOCKET socket);

            /**
             * @brief
             * Destructor.
             */
            virtual ~InputThread();

            /**
             * @brief
             * Halt the thread's execution.
             */
            virtual void halt();

        protected:
            /**
             * @brief
             * The method that the thread executes.
             */
            virtual void run();

            /**
             * @brief
             * Initialize structures passed to the server's select call.
             *
             * @return The last socket descriptor handle + 1.
             */
            virtual int setup_select();

        protected:
            TCPConnection&          _conn;              ///< Reference to server serviced by this read thread.
            std::auto_ptr<IMutex>   _mutex;             ///< IMutex for synch.        
            unsigned short          _port;              ///< Server port
            SOCKET                  _socket;            ///< Socket to read/write.
            fd_set                  _rfds;              ///< Read descriptor set.
            fd_set                  _xfds;              ///< Exception descriptor set.
            std::auto_ptr<ISocketProtocol> _protocol;   ///< Protocol object used to encode/decode.
        };

        /**
         * @class OutputThread
         * @ingroup core_util
         * @brief
         * Thread that handles the socket output. 
         */
        class EVOLUTION_EXPORT_UTIL OutputThread : public SignalThread  
        {
        public:
            /**
             * @brief
             * Constructor.
             *
             * @param   conn     [in]; The reference to the connection 
             *      serviced by this thread.
             * @param   protocol [in]; Which protocol to use on the socket.
             * @param   socket   [in]; The socket on which this thread 
             *      will operate.
             */
            OutputThread(TCPConnection& conn, ISocketProtocol* protocol, SOCKET socket);

            /**
             * @brief
             * Destructor.
             */
            virtual ~OutputThread();

            /**
             * @brief
             * Halt the thread's execution.
             */
            virtual void halt();

            /**
             * @brief
             * Queue the buffer to be sent on the socket.  
             *
             * This method copies the buffer so you can delete the 
             * buffer immediately after the call.
             *
             * @param buffer [in]; Pointer to the buffer to send.
             * @param len [in]; The length of the buffer to send.
             *
             * @return True on success, false on failure.
             */
            virtual bool send(const char* buffer, int len);

            /**
             * @brief
             * Queue the buffer to be sent on the socket.
             * 
             * Copies the buffer so you can delete the buffer immediately after
             * the call.  
             *
             * @param buffer [in]; Pointer to the buffer to send.
             * @param len [in]; The length of the buffer to send.
             * @param queue_length [in]; The maximum length of queue before 
             *      dropping the message.
             *
             * @return true on success, false on failure or if
             *      the message was dropped.
             */
            virtual bool send_check_queue_length(const char* buffer, int len, size_t queue_length);
            
        protected:
            /**
             * @brief
             * The code that the thread executes.
             */
            virtual void run();

            /**
             * @brief
             * Initialize structures passed to the server's select call.
             *
             * @return The last socket descriptor handle + 1.
             */
            virtual int setup_select();

            /**
             * @brief
             * Refill the send buffer from the message queue if necessary.
             */
            void refill_buffer();

            /**
             * @brief
             * Common send code for send() and send_check_queue_length().
             * 
             * @param buffer [in]; Pointer to the buffer to send.
             * @param len [in]; The length of the buffer to send.
             *
             * @return True on success, false on failure.
             */
            virtual bool send_common(const char* buffer, int len);

        protected:
            TCPConnection&          _conn;              ///< Reference to server serviced by this read thread.
            std::auto_ptr<IConditionVariable> _signal_new_data;   ///< Condition variable used to signal arrival of new data to send.
            unsigned short          _port;              ///< Server port
            SOCKET                  _socket;            ///< Socket to read/write.
            fd_set                  _wfds;              ///< Write descriptor set.
            fd_set                  _xfds;              ///< Exception descriptor set.
            const char*             _buffer;            ///< Buffer containing data to be written on the socket.  Not owned by this object.
            size_t                  _bsize;             ///< Size of buffer
            std::auto_ptr<ISocketProtocol> _protocol;   ///< Protocol object used to encode/decode.
            size_t                  _queue_total_bytes; ///< Number of bytes in the queue.
            std::list<char*>        _queue_buffers;     ///< Queue of buffer pointers.
            std::list<size_t>       _queue_sizes;       ///< Queue of buffer sizes.
        };
    };

    /**
     * @brief
     * The auto pointer type for TCPConnection.
     */
    typedef RefPtr<TCPConnection> TCPConnectionPtr;
}

#endif 
